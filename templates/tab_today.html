<div id="todaydata" class="tabcontent" style="display:block;">
  <h2>Daily Farm Data Entry</h2>

  <!-- Date Navigation -->
  <div id="date-navigation" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
    <button id="prev-day-btn" onclick="navigateDay(-1)" style="padding: 8px 15px; font-size: 14px; cursor: pointer;">← Previous Day</button>
    <input type="date" id="date-picker" onchange="loadDateData(this.value, true)" style="padding: 8px; font-size: 14px; cursor: pointer;">
    <button id="next-day-btn" onclick="navigateDay(1)" style="padding: 8px 15px; font-size: 14px; cursor: pointer;">Next Day →</button>
    <span id="current-date-display" style="font-weight: bold; margin-left: 10px; font-size: 16px;"></span>
  </div>

  <h3>Daily User Log</h3>
  <div id="userlog-container">
    <p>Loading...</p>
  </div>

  <h3>Daily Bot Log</h3>
  <div id="botlog-container">
    <p>Loading...</p>
  </div>
</div>

<script>
  // Global variable to track the currently selected date
  let currentSelectedDate = null;

  function loadTodayData() {
    // Initialize with today's date
    const today = new Date().toISOString().split('T')[0];
    currentSelectedDate = today;

    // Set date picker to today
    document.getElementById('date-picker').value = today;
    document.getElementById('date-picker').max = today; // Can't select future dates

    // Load today's data
    loadDateData(today);
  }

  function loadDateData(dateStr, skipIfLocked = false) {
    // If skipIfLocked is true, check if this date is locked first
    if (skipIfLocked) {
      fetch(`/api/check_send_to_bot?date=${dateStr}`)
        .then(res => res.json())
        .then(result => {
          if (result.send_to_bot) {
            // This date is locked, find the nearest editable date
            fetch(`/api/find_editable_date?start_date=${dateStr}&direction=prev`)
              .then(res => res.json())
              .then(prevResult => {
                if (prevResult.found) {
                  // Load the previous editable date instead
                  document.getElementById('date-picker').value = prevResult.date;
                  loadDateData(prevResult.date, false);
                } else {
                  // Try next direction
                  fetch(`/api/find_editable_date?start_date=${dateStr}&direction=next`)
                    .then(res => res.json())
                    .then(nextResult => {
                      if (nextResult.found) {
                        document.getElementById('date-picker').value = nextResult.date;
                        loadDateData(nextResult.date, false);
                      } else {
                        alert('No editable dates available.');
                      }
                    });
                }
              });
            return;
          } else {
            // Not locked, continue with normal load
            loadDateDataInternal(dateStr);
          }
        })
        .catch(err => {
          console.error('Error checking send_to_bot:', err);
          loadDateDataInternal(dateStr);
        });
    } else {
      loadDateDataInternal(dateStr);
    }
  }

  function loadDateDataInternal(dateStr) {
    currentSelectedDate = dateStr;

    // Update display
    updateDateDisplay(dateStr);
    updateNavigationButtons();

    // Load both the date's data and defaults
    Promise.all([
      fetch(`/api/date_data?date=${dateStr}`).then(res => res.json()),
      fetch('/get_defaults').then(res => res.json())
    ])
      .then(([dateData, defaults]) => {
        // If no user_log exists, apply defaults
        if (!dateData.user_log) {
          dateData.user_log = defaults;
        }
        renderUserLog(dateData.user_log);
        renderBotLog(dateData.bot_log);
      })
      .catch(err => {
        console.error('Error loading date data:', err);
        document.getElementById('userlog-container').innerHTML = '<p>Error loading user log.</p>';
        document.getElementById('botlog-container').innerHTML = '<p>Error loading bot log.</p>';
      });
  }

  function navigateDay(offset) {
    const direction = offset < 0 ? 'prev' : 'next';

    // Find the next editable date in the given direction
    fetch(`/api/find_editable_date?start_date=${currentSelectedDate}&direction=${direction}`)
      .then(res => res.json())
      .then(result => {
        if (result.found) {
          document.getElementById('date-picker').value = result.date;
          loadDateData(result.date);
        } else {
          console.log(`No editable date found in ${direction} direction`);
        }
      })
      .catch(err => {
        console.error('Error finding editable date:', err);
      });
  }

  function updateDateDisplay(dateStr) {
    const date = new Date(dateStr + 'T00:00:00');
    const today = new Date().toISOString().split('T')[0];
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const formattedDate = date.toLocaleDateString('en-US', options);

    let displayText = formattedDate;
    if (dateStr === today) {
      displayText += ' (Today)';
    }

    document.getElementById('current-date-display').textContent = displayText;
  }

  function updateNavigationButtons() {
    const prevBtn = document.getElementById('prev-day-btn');
    const nextBtn = document.getElementById('next-day-btn');
    const datePicker = document.getElementById('date-picker');

    // Check if there are editable dates in each direction
    Promise.all([
      fetch(`/api/find_editable_date?start_date=${currentSelectedDate}&direction=prev`).then(res => res.json()),
      fetch(`/api/find_editable_date?start_date=${currentSelectedDate}&direction=next`).then(res => res.json())
    ]).then(([prevResult, nextResult]) => {
      // Update prev button
      if (prevResult.found) {
        prevBtn.disabled = false;
        prevBtn.style.opacity = '1';
        prevBtn.style.cursor = 'pointer';
      } else {
        prevBtn.disabled = true;
        prevBtn.style.opacity = '0.5';
        prevBtn.style.cursor = 'not-allowed';
      }

      // Update next button
      if (nextResult.found) {
        nextBtn.disabled = false;
        nextBtn.style.opacity = '1';
        nextBtn.style.cursor = 'pointer';
      } else {
        nextBtn.disabled = true;
        nextBtn.style.opacity = '0.5';
        nextBtn.style.cursor = 'not-allowed';
      }

      // Disable date picker if no dates available in either direction
      if (!prevResult.found && !nextResult.found) {
        datePicker.disabled = true;
        datePicker.style.opacity = '0.5';
        datePicker.style.cursor = 'not-allowed';
      } else {
        datePicker.disabled = false;
        datePicker.style.opacity = '1';
        datePicker.style.cursor = 'pointer';
      }
    }).catch(err => {
      console.error('Error updating navigation buttons:', err);
    });
  }

  function renderUserLog(user_log) {
    const container = document.getElementById('userlog-container');

    // Define the expected fields for user log
    const userLogFields = [
      'date_entered',
      'belt_eggs',
      'floor_eggs',
      'mortality_indoor',
      'mortality_outdoor',
      'euthanized_indoor',
      'euthanized_outdoor',
      'mortality_reasons',
      'cull_reasons',
      'mortality_comments',
      'eggs_picked_up',
      'coolerlog_comments',
      'added_supplements',
      'ration',
      'amount_delivered',
      'birds_restricted_reason',
      'comments',
      'weather',
      'nutritionist',
      'ration_used',
      'air_sensory',
      'drinkers_clean',
      'birds_under_slats',
      'safe_indoors',
      'safe_outdoors',
      'equipment_functioning',
      'predator_activity',
      'depop',
      'door_open',
      'door_closed',
      'send_to_bot'
    ];

    // Define display names for fields
    const fieldDisplayNames = {
      'id': 'ID',
      'date_entered': 'Date Entered',
      'send_to_bot': 'Send to Unitas',
      'belt_eggs': 'Belt Eggs',
      'floor_eggs': 'Floor Eggs',
      'mortality_indoor': 'Mortality Indoor',
      'mortality_outdoor': 'Mortality Outdoor',
      'euthanized_indoor': 'Euthanized Indoor',
      'euthanized_outdoor': 'Euthanized Outdoor',
      'depop': 'Depop #',
      'amount_delivered': 'Amount Delivered',
      'mortality_reasons': 'Mortality Reasons',
      'cull_reasons': 'Cull Reasons',
      'mortality_comments': 'Mortality Comments',
      'coolerlog_comments': 'Cooler Log Comments',
      'added_supplements': 'Added Supplements',
      'birds_restricted_reason': 'Birds Restricted Reason',
      'comments': 'Comments',
      'weather': 'Weather',
      'nutritionist': 'Nutritionist',
      'ration_used': 'Ration Used',
      'air_sensory': 'Air Sensory',
      'ration': 'Ration Delivered',
      'drinkers_clean': 'Drinkers Clean',
      'birds_under_slats': 'Birds Under Slats',
      'safe_indoors': 'Safe Indoors',
      'safe_outdoors': 'Safe Outdoors',
      'equipment_functioning': 'Equipment Functioning',
      'predator_activity': 'Predator Activity',
      'eggs_picked_up': 'Eggs Picked Up',
      'door_open': 'Door Open',
      'door_closed': 'Door Closed'
    };

    // If no user_log, create empty object with all fields
    if (!user_log) {
      user_log = {};
      userLogFields.forEach(field => {
        user_log[field] = '';
      });
    }

    let html = '<div id="userlog-scroll-container" style="max-width:100%; max-height:600px; overflow:auto; border:1px solid #ccc; border-radius:6px; padding:10px;">';
    html += '<form id="userlog-edit-form">';
    html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 200px)); gap:10px;">';

    // Render each field as a labeled input in a grid
    for (const key of userLogFields) {
      const value = user_log[key] || '';
      const isReadonly = key === 'id' || key === 'date_entered' ? 'readonly' : '';
      const displayName = fieldDisplayNames[key] || key;

      html += `<div style="display:flex; flex-direction:column;">`;
      html += `<label style="font-weight:bold; margin-bottom:2px; font-size:11px;">${displayName}</label>`;

      // Special handling for fields with dropdowns
      if (key === 'mortality_reasons') {
        html += `<input style="padding:4px; font-size:12px; cursor:pointer;" name="${key}" value="${value}" readonly onfocus="showMortalityReasonsDropdown(this)" onblur="hideDropdownDelayed()" onclick="showMortalityReasonsDropdown(this)">`;
      } else if (key === 'cull_reasons') {
        html += `<input style="padding:4px; font-size:12px; cursor:pointer;" name="${key}" value="${value}" readonly onfocus="showCullReasonsDropdown(this)" onblur="hideDropdownDelayed()" onclick="showCullReasonsDropdown(this)">`;
      } else if (key === 'air_sensory') {
        html += `<input style="padding:4px; font-size:12px; cursor:pointer;" name="${key}" value="${value}" readonly onfocus="showAirSensoryDropdown(this)" onblur="hideDropdownDelayed()" onclick="showAirSensoryDropdown(this)">`;
      } else if (key === 'weather') {
        html += `<input style="padding:4px; font-size:12px; cursor:pointer;" name="${key}" value="${value}" readonly onfocus="showWeatherDropdown(this)" onblur="hideDropdownDelayed()" onclick="showWeatherDropdown(this)">`;
      } else if (key === 'nutritionist') {
        html += `<input style="padding:4px; font-size:12px; cursor:pointer;" name="${key}" value="${value}" readonly onfocus="showNutritionistDropdown(this)" onblur="hideDropdownDelayed()" onclick="showNutritionistDropdown(this)">`;
      } else if (key === 'ration_used') {
        html += `<input style="padding:4px; font-size:12px; cursor:pointer;" name="${key}" value="${value}" readonly onfocus="showRationUsedDropdown(this)" onblur="hideDropdownDelayed()" onclick="showRationUsedDropdown(this)">`;
      } else if (key === 'send_to_bot' || key === 'eggs_picked_up' || key === 'drinkers_clean' || key === 'birds_under_slats' || key === 'safe_indoors' || key === 'safe_outdoors' || key === 'equipment_functioning' || key === 'predator_activity') {
        const isChecked = (value === 'Yes' || value === 'true' || value === true || value === 1 || value === '1') ? 'checked' : '';
        html += `<input type="checkbox" name="${key}" ${isChecked} onchange="updateCheckboxField(this)" style="width:18px; height:18px;">`;
      } else {
        html += `<input style="padding:4px; font-size:12px;" name="${key}" value="${value}" ${isReadonly} oninput="autoSaveUserLog()">`;
      }

      html += `</div>`;
    }

    html += '</div></form></div>';
    container.innerHTML = html;

    // Run validation after rendering
    setTimeout(() => validateAndHighlight(), 100);
  }

  function scrollUserLogToInput(input) {
    const container = document.getElementById('userlog-scroll-container');
    if (!container) return;

    const inputRect = input.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    // Scroll horizontally if input is outside visible area
    if (inputRect.right > containerRect.right - 20) {
      container.scrollLeft += (inputRect.right - containerRect.right + 120);
    } else if (inputRect.left < containerRect.left + 20) {
      container.scrollLeft -= (containerRect.left - inputRect.left + 120);
    }
  }

  let currentDropdownInput = null;
  let hideTimeout = null;

  function showMortalityReasonsDropdown(input) {
    hideDropdown(); // Close any existing dropdown

    const mortalityOptions = ['Unknown', 'N Natural', 'PR Predator', 'PC Pecking', 'S Sick', 'PL Prolapse', 'C Cull', 'B Broody', 'O Other', 'PI Piling', 'SO Starveout', 'I Injured'];
    const currentValues = input.value ? input.value.split(',').map(v => v.trim()) : [];

    let html = '<div style="padding:10px; max-height:200px; overflow-y:auto;">';
    mortalityOptions.forEach(opt => {
      const checked = currentValues.includes(opt) ? 'checked' : '';
      html += `<label style="display:block; margin:3px 0; white-space:nowrap;"><input type="checkbox" value="${opt}" ${checked} onchange="updateMortalityFromDropdown(this)"> ${opt}</label>`;
    });
    html += '</div>';

    showDropdown(html, input);
    currentDropdownInput = input;
  }

  function showCullReasonsDropdown(input) {
    hideDropdown(); // Close any existing dropdown

    const cullOptions = ['Aggressive', 'Broody', 'Injured', 'Rooster', 'Runt', 'Sick'];
    const currentValues = input.value ? input.value.split(',').map(v => v.trim()) : [];

    let html = '<div style="padding:10px;">';
    cullOptions.forEach(opt => {
      const checked = currentValues.includes(opt) ? 'checked' : '';
      html += `<label style="display:block; margin:3px 0; white-space:nowrap;"><input type="checkbox" value="${opt}" ${checked} onchange="updateCullFromDropdown(this)"> ${opt}</label>`;
    });
    html += '</div>';

    showDropdown(html, input);
    currentDropdownInput = input;
  }

  function showAirSensoryDropdown(input) {
    hideDropdown(); // Close any existing dropdown

    const airSensoryOptions = ['1', '2', '3', '4', '5'];
    const currentValue = input.value;

    let html = '<div style="padding:10px;">';
    airSensoryOptions.forEach(opt => {
      const checked = currentValue === opt ? 'checked' : '';
      html += `<label style="display:block; margin:3px 0; white-space:nowrap;"><input type="radio" name="air_sensory_dropdown" value="${opt}" ${checked} onchange="updateAirSensoryFromDropdown(this)"> ${opt}</label>`;
    });
    html += '</div>';

    showDropdown(html, input);
    currentDropdownInput = input;
  }

  function showWeatherDropdown(input) {
    hideDropdown(); // Close any existing dropdown

    const weatherOptions = ['Cloudy', 'Cloudy/Windy', 'Freezing Rain', 'Mostly Cloudy', 'Partly Cloudy', 'Partly Sunny', 'Rain', 'Severe Storm', 'Sleet', 'Snow', 'Sunny', 'Winter Storm'];
    const currentValue = input.value;

    let html = '<div style="padding:10px; max-height:300px; overflow-y:auto;">';
    weatherOptions.forEach(opt => {
      const checked = currentValue === opt ? 'checked' : '';
      html += `<label style="display:block; margin:3px 0; white-space:nowrap;"><input type="radio" name="weather_dropdown" value="${opt}" ${checked} onchange="updateWeatherFromDropdown(this)"> ${opt}</label>`;
    });
    html += '</div>';

    showDropdown(html, input);
    currentDropdownInput = input;
  }

  function showNutritionistDropdown(input) {
    hideDropdown(); // Close any existing dropdown

    const nutritionistOptions = ['Dr. Bowen', 'Kristjan Bregendahl', 'Ridley', 'Doesnt consult nutritionist'];
    const currentValue = input.value;

    let html = '<div style="padding:10px;">';
    nutritionistOptions.forEach(opt => {
      const checked = currentValue === opt ? 'checked' : '';
      html += `<label style="display:block; margin:3px 0; white-space:nowrap;"><input type="radio" name="nutritionist_dropdown" value="${opt}" ${checked} onchange="updateNutritionistFromDropdown(this)"> ${opt}</label>`;
    });
    html += '</div>';

    showDropdown(html, input);
    currentDropdownInput = input;
  }

  function showRationUsedDropdown(input) {
    hideDropdown(); // Close any existing dropdown

    const rationUsedOptions = ['Cocc', 'E. coli', 'Fowl Cholera', 'FP-PP-AE', 'IBD', 'IBV', 'IBV/NDV/SE', 'LT', 'Mareks', 'Mareks-LT', 'NDV', 'Spotty Liver', 'ST', 'Phase 1-19', 'Phase 1-20', 'Phase 1-21', 'Phase 1-22', 'Phase 1-23', 'Phase 1-24', 'Phase 1-25', 'Phase 1-26', 'Phase 1-27', 'Phase 1-28', 'Phase 2-20', 'Phase 2-21', 'Phase 2-22', 'Phase 2-23', 'Phase 2-24', 'Phase 2-25', 'Phase 2-26', 'Phase 2-27', 'Phase 2-28', 'Phase 2-29', 'Phase 2-30', 'Phase 3-21', 'Phase 3-22', 'Phase 3-23', 'Phase 3-24', 'Phase 3-25', 'Phase 3-26', 'Phase 3-27', 'Phase 3-28', 'Phase 3-29', 'Phase 3-30', 'Phase 3-31', 'Phase 4-21', 'Phase 4-22', 'Phase 4-23', 'Phase 4-24', 'Phase 4-25', 'Phase 4-26', 'Phase 4-27', 'Phase 4-28', 'Phase 4-29', 'Phase 4-30', 'Phase 4-31', 'Phase 5-21', 'Phase 5-22', 'Phase 5-23', 'Phase 5-24', 'Phase 5-25', 'Phase 5-26', 'Phase 5-27', 'Phase 5-28', 'Phase 5-29', 'Phase 5-30', 'Phase 5-31', 'Phase 6-21', 'Phase 6-22', 'Phase 6-23', 'Phase 6-24', 'Phase 6-25', 'Phase 6-26', 'Phase 6-27', 'Phase 6-28', 'Phase 6-29', 'Phase 6-30', 'Phase 6-31', 'Developer', 'PreLay', 'Phase 2 Lay 21', 'Phase 2 Lay 22', 'Phase 2 Lay 23', 'Phase 2 Lay 24', 'Phase 2 Lay 25', 'Phase 2 Lay 26', 'Phase 2 Lay 27', 'Phase 2 Lay 28', 'Phase 2 Lay 29', 'Phase 2 Lay 30', 'Phase 3 Lay 21', 'Phase 3 Lay 22', 'Phase 3 Lay 23', 'Phase 3 Lay 24', 'Phase 3 Lay 25', 'Phase 3 Lay 26', 'Phase 3 Lay 27', 'Phase 3 Lay 28', 'Phase 3 Lay 29', 'Phase 3 Lay 30', 'Phase 4 Lay 21', 'Phase 4 Lay 22', 'Phase 4 Lay 23', 'Phase 4 Lay 24', 'Phase 4 Lay 25', 'Phase 4 Lay 26', 'Phase 4 Lay 27', 'Phase 4 Lay 28', 'Phase 4 Lay 29', 'Phase 4 Lay 30', 'Phase 5 Lay 30', 'Peak 1', 'Peak 2', 'Peak 3', 'Peak Lay 19', 'Peak Lay 20', 'Peak Lay 21', 'Peak Lay 22', 'Peak Lay 23', 'Peak Lay 24', 'Peak Lay 25', 'Peak Lay 26', 'Peak Lay 27', 'Peak Lay 28', 'Peak Lay 29', 'Peak Lay 30', 'PreLay', 'Pullet Grower', 'Pullet Starter 1', 'Pullet Starter 2'];
    const currentValue = input.value;

    let html = '<div style="padding:10px; max-height:400px; overflow-y:auto;">';
    rationUsedOptions.forEach(opt => {
      const checked = currentValue === opt ? 'checked' : '';
      html += `<label style="display:block; margin:3px 0; white-space:nowrap;"><input type="radio" name="ration_used_dropdown" value="${opt}" ${checked} onchange="updateRationUsedFromDropdown(this)"> ${opt}</label>`;
    });
    html += '</div>';

    showDropdown(html, input);
    currentDropdownInput = input;
  }

  function showDropdown(content, inputElement) {
    // Create dropdown positioned relative to the input but outside the scroll container
    const dropdown = document.createElement('div');
    dropdown.id = 'field-dropdown';
    dropdown.innerHTML = content;
    dropdown.onmousedown = (e) => e.preventDefault(); // Prevent blur when clicking inside

    // Position it fixed relative to the input's position on screen
    const rect = inputElement.getBoundingClientRect();
    dropdown.style.cssText = `position:fixed; top:${rect.bottom + 2}px; left:${rect.left}px; background:white; border:1px solid #ccc; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.3); z-index:10000; min-width:200px;`;

    document.body.appendChild(dropdown);
  }

  function hideDropdown() {
    const dropdown = document.getElementById('field-dropdown');
    if (dropdown) {
      dropdown.remove();
    }
    currentDropdownInput = null;
  }

  function hideDropdownDelayed() {
    // Delay hiding to allow clicking on checkboxes
    hideTimeout = setTimeout(hideDropdown, 200);
  }

  function updateMortalityFromDropdown(checkbox) {
    if (hideTimeout) {
      clearTimeout(hideTimeout);
    }

    const dropdown = checkbox.closest('div');
    const checkboxes = dropdown.querySelectorAll('input[type="checkbox"]:checked');
    const values = Array.from(checkboxes).map(cb => cb.value);

    if (currentDropdownInput) {
      currentDropdownInput.value = values.join(', ');
      validateAndHighlight();
      autoSaveUserLog();
    }
  }

  function updateCullFromDropdown(checkbox) {
    if (hideTimeout) {
      clearTimeout(hideTimeout);
    }

    const dropdown = checkbox.closest('div');
    const checkboxes = dropdown.querySelectorAll('input[type="checkbox"]:checked');
    const values = Array.from(checkboxes).map(cb => cb.value);

    if (currentDropdownInput) {
      currentDropdownInput.value = values.join(', ');
      validateAndHighlight();
      autoSaveUserLog();
    }
  }

  function updateAirSensoryFromDropdown(radio) {
    if (hideTimeout) {
      clearTimeout(hideTimeout);
    }

    if (currentDropdownInput) {
      currentDropdownInput.value = radio.value;
      validateAndHighlight();
      autoSaveUserLog();
      // Close dropdown after selection since it's radio (single choice)
      setTimeout(hideDropdown, 100);
    }
  }

  function updateWeatherFromDropdown(radio) {
    if (hideTimeout) {
      clearTimeout(hideTimeout);
    }

    if (currentDropdownInput) {
      currentDropdownInput.value = radio.value;
      validateAndHighlight();
      autoSaveUserLog();
      // Close dropdown after selection since it's radio (single choice)
      setTimeout(hideDropdown, 100);
    }
  }

  function updateNutritionistFromDropdown(radio) {
    if (hideTimeout) {
      clearTimeout(hideTimeout);
    }

    if (currentDropdownInput) {
      currentDropdownInput.value = radio.value;
      validateAndHighlight();
      autoSaveUserLog();
      // Close dropdown after selection since it's radio (single choice)
      setTimeout(hideDropdown, 100);
    }
  }

  function updateRationUsedFromDropdown(radio) {
    if (hideTimeout) {
      clearTimeout(hideTimeout);
    }

    if (currentDropdownInput) {
      currentDropdownInput.value = radio.value;
      validateAndHighlight();
      autoSaveUserLog();
      // Close dropdown after selection since it's radio (single choice)
      setTimeout(hideDropdown, 100);
    }
  }

  function updateCheckboxField(checkbox) {
    // Update the value based on checkbox state
    const value = checkbox.checked ? 'Yes' : 'No';
    // We need to trigger auto-save with the updated value
    // The checkbox doesn't have a "value" attribute in the traditional sense for form data
    // So we'll need to handle it in the autoSaveUserLog function
    autoSaveUserLog();

    // If this is the send_to_bot checkbox, update navigation buttons
    if (checkbox.name === 'send_to_bot') {
      // Wait a bit for the save to complete, then update buttons
      setTimeout(() => {
        updateNavigationButtons();
      }, 600);
    }
  }

  let saveTimeout = null;
  function autoSaveUserLog() {
    // Clear any existing timeout
    if (saveTimeout) {
      clearTimeout(saveTimeout);
    }

    // Set a new timeout to save after a brief delay (debounce)
    saveTimeout = setTimeout(() => {
      const form = document.getElementById('userlog-edit-form');
      const data = {};

      // Handle regular inputs (all non-checkbox inputs)
      const inputs = form.querySelectorAll('input:not([type="checkbox"]), textarea');
      inputs.forEach(input => {
        if (input.name && input.name !== 'id' && input.name !== 'date_entered') {
          data[input.name] = input.value;
        }
      });

      // Handle checkboxes - convert to Yes/No or 0/1 depending on field
      const checkboxes = form.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        if (checkbox.name && checkbox.name !== 'id' && checkbox.name !== 'date_entered') {
          // send_to_bot uses 0/1, others use Yes/No
          if (checkbox.name === 'send_to_bot') {
            data[checkbox.name] = checkbox.checked ? 1 : 0;
          } else {
            data[checkbox.name] = checkbox.checked ? 'Yes' : 'No';
          }
        }
      });

      // Include the selected date in the request
      fetch(`/update_user_log?date=${currentSelectedDate}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
        .then(res => res.json())
        .then(result => {
          console.log('Auto-saved:', result.message);
          // Run validation after save
          validateAndHighlight();
        })
        .catch(err => {
          console.error('Auto-save failed:', err);
        });
    }, 500); // Wait 500ms after user stops typing
  }

  function validateAndHighlight() {
    const form = document.getElementById('userlog-edit-form');
    if (!form) return;

    // Get all form data
    const getValue = (name) => {
      const el = form.querySelector(`[name="${name}"]`);
      if (!el) return '';
      if (el.type === 'checkbox') return el.checked ? (name === 'send_to_bot' ? 1 : 'Yes') : (name === 'send_to_bot' ? 0 : 'No');
      return el.value || '';
    };

    // Check each field and apply red border if invalid
    const checkField = (fieldName, isInvalid) => {
      const el = form.querySelector(`[name="${fieldName}"]`);
      if (el && el.name !== 'id' && el.name !== 'date_entered') {
        el.style.border = isInvalid ? '2px solid red' : '';
      }
    };

    // 1. Birds restricted reason - red if door open/close are empty
    const doorOpen = getValue('door_open').trim();
    const doorClosed = getValue('door_closed').trim();
    const birdsRestricted = getValue('birds_restricted_reason').trim();
    checkField('birds_restricted_reason', (doorOpen === '' || doorClosed === '') && birdsRestricted === '');

    // 2. Mortality reasons - red if mortality indoor/outdoor have values
    const mortalityIndoor = parseInt(getValue('mortality_indoor')) || 0;
    const mortalityOutdoor = parseInt(getValue('mortality_outdoor')) || 0;
    const mortalityReasons = getValue('mortality_reasons').trim();
    checkField('mortality_reasons', (mortalityIndoor > 0 || mortalityOutdoor > 0) && mortalityReasons === '');

    // 3. Cull reasons - red if euthanized indoor/outdoor have values
    const euthanizedIndoor = parseInt(getValue('euthanized_indoor')) || 0;
    const euthanizedOutdoor = parseInt(getValue('euthanized_outdoor')) || 0;
    const cullReasons = getValue('cull_reasons').trim();
    checkField('cull_reasons', (euthanizedIndoor > 0 || euthanizedOutdoor > 0) && cullReasons === '');

    // 4. Always required fields - red if empty
    checkField('belt_eggs', getValue('belt_eggs').trim() === '');
    checkField('floor_eggs', getValue('floor_eggs').trim() === '');
    checkField('weather', getValue('weather').trim() === '');
    checkField('air_sensory', getValue('air_sensory').trim() === '');
    checkField('nutritionist', getValue('nutritionist').trim() === '');
    checkField('ration_used', getValue('ration_used').trim() === '');
  }

  function renderBotLog(bot_log) {
    const container = document.getElementById('botlog-container');
    if (!bot_log) {
      container.innerHTML = '<p>No bot log for today.</p>';
      return;
    }

    let html = '<div style="max-width:100%; max-height:220px; overflow:auto; border:1px solid #ccc; border-radius:6px;">';
    html += '<form id="botlog-edit-form"><table style="font-size:12px; min-width:600px;"><tr>';
    html += '<th style="padding:4px 6px;">Flag</th>';
    for (const key in bot_log) {
      html += `<th style="padding:4px 6px;">${key}</th>`;
    }
    html += '<th style="padding:4px 6px;">Save</th></tr><tr>';
    html += '<td style="padding:4px 6px;"><input type="checkbox" id="botlog-flag" onchange="setFlag(\'BOT_LOG_FLAG\', this.checked)"></td>';
    for (const key in bot_log) {
      const value = bot_log[key] || '';
      html += `<td style="padding:4px 6px;"><input style="width:100px; font-size:12px;" name="${key}" value="${value}"></td>`;
    }
    html += '<td><button type="button" onclick="saveBotLog()">Save</button></td>';
    html += '</tr></table></form></div>';
    container.innerHTML = html;
  }

  function setFlag(flag, checked) {
    if (!checked) return; // Only set flag on check
    fetch('/set_flag', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ flag: flag })
    })
      .then(res => res.json())
      .then(data => alert(data.message))
      .catch(() => alert('Error setting flag.'));
  }

  function saveUserLog() {
    const form = document.getElementById('userlog-edit-form');
    const formData = new FormData(form);
    const data = {};
    formData.forEach((value, key) => { data[key] = value; });
    fetch('/update_user_log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
      .then(res => res.json())
      .then(data => alert(data.message))
      .catch(() => alert('Error saving user log.'));
  }

  function saveBotLog() {
    const form = document.getElementById('botlog-edit-form');
    const formData = new FormData(form);
    const data = {};
    formData.forEach((value, key) => { data[key] = value; });
    fetch('/update_bot_log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
      .then(res => res.json())
      .then(data => alert(data.message))
      .catch(() => alert('Error saving bot log.'));
  }
</script>
